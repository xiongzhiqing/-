/**
 * 树形思维模型将帮助我们更迅速地定位到状态转移关系，边界条件往往对应的就是已知子问题的解；
*/
// 最值问题是动态规划的常见对口题型，见到最值问题，应该想到动态规划
/**
 *
 *
 * 记忆化搜索与动态规划之间的区别：
 *
 * 记忆化搜索可以理解为优化后的递归。递归往往可以基于树形思维模型来做。（自顶向下的过程）
 *
 * 动态规划和记忆化搜索恰恰相反，是一个自底向上的过程。
 * 站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。
 *
 * 动态规划使用场景（关键特征）
 *  1、最优子结构
 *     指问题的最优解包含着子问题的最优解 -- 不管前面的决策如何，此后的状态必须是基于当前状态（由上次决策产生）的最优决策。（状态转移方案）
 *  2、重叠子问题
 *     指的是在递归的过程中，出现了反复计算的情况。
 *
 *
 * 动态规划复杂：
 *  1、状态转移方程不好确认
 *  2、已知的状态可能不明显
 *  3、递归转迭代
 *
 * 动态规划分析路径：
 *  1、递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系。
 *  2、结合记忆化搜索，明确状态转移方程。
 *  3、递归代码转化为迭代表达（非必要，1、2本身为思维路径，而并非代码实现。若是熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。
*/

/**
 * 分治：
 *  分治问题的核心思想是： 把一个问题分解为相互独立的子问题，逐个解决子问题后，再组合子问题的答案，就得到了问题的最终解。
 * 动态规划：
 *  动态规划思想和“分治”有点相似。不同之处在于，“分治”思想中，各个子问题之间是独立的：
 *  比如说归并排序中，子数组之间的排序并不互相影响。而动态规划划分出的子问题，往往是相互依赖、相互影响的。
*/

// 记忆化搜索提效

// 递归解法：
// 记忆数组
const f = []
const climbStairs = function (n) {
  if (n === 1) return 1
  if (n === 2) return 2

  if (f[n] === undefined) f[n] = climbStairs(n - 1) + climbStairs(n - 2)
  return f[n]
}

console.time('climbStairs_递归')
climbStairs(10)

console.timeEnd('climbStairs_递归')

// 动态规划解法
// 以 f(1) 和 f(2) 为起点，不断求和，循环递增 n 的值，求出 f(n)

const climbStairs1 = function (n) {
  // 初始化状态数组
  const f = []
  // 初始化已知值
  f[1] = 1
  f[2] = 2

  // 动态更新每一层楼梯对应的结果
  for (let i = 3; i <= n; i++) {
    f[i] = f[i - 2] + f[i - 1]
  }
  return f[n]
}


console.time('climbStairs_动态规划')
climbStairs1(10)
console.timeEnd('climbStairs_动态规划')
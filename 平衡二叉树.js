// ***** 二叉搜索树是二叉树的特例，平衡二叉树则是二叉搜索树的特例。

// 平衡二叉树：（又称AVL Tree）指的是任意结点的左右子树高度差绝对值都不大于1的二叉搜索树。

// 为什么要有平衡二叉树
// 平衡二叉树的出现，是为了降低二叉搜索树的查找时间复杂度。
// 对于同样一个序列，二叉搜索树的造型可以有很多种。


// 平衡二叉树比非平衡二叉树的查找效率要高。


// 二叉搜索树的妙处就是在于它把“二分”這种思想以数据结构的形式表达了出来。
// 在一个构造合理的二叉搜索树里，可以通过对比当前结点和目标值之间的大小关系，缩小下一步的搜索范围（比如只搜索左子树或者只搜索右子树），进而规避掉不必要的查找步骤，降低搜索过程的时间复杂度。

// 平衡二叉树由于利用了二分思想，查找操作的时间复杂度仅为O(logN)。因此，为了保证二叉搜索树能够缺失为查找操作带来效率上的提升，有必要在构造二叉搜索树的过程中维持其平衡度，这就是平衡二叉树的来由。


/**
 * 命题思路解读
 *
 * 平衡二叉树和二叉搜索树一样，都被归类为“特殊”的二叉树。对于这样的数据结构来说，其“特殊”之处也正是其考点所在，因此真题往往稳定地分布在一下两个方向：
 *  1、对特性的考察（以对平衡二叉树的判定为例）
 *  2、对操作的考察（以对平衡二叉树的构造为例）
 *
 * */

/**
 * *** 平衡二叉树的判定
 *
 * 题目1：
 * 给定一个二叉树，判断它是否是高度平衡的二叉树。
 * 本题中，一颗高度平衡二叉树定义为：一个二叉树每个节点的 左右子树的高度差的绝对值不超过1。
 *
 * 示例1：给定二叉树[3,9,20,null, nul, 15, 7]
 *   3
    / \
   9   20
      /  \
     15   7
 * 返回： true

 * 示例2：给定二叉树[1,2,2,3,3,null,null,4,4]
 *         1
          / \
         2   2
        / \
       3   3
      / \
     4   4
 * 返回：false
 *
 * 解法（思路分析）：
 * 平衡二叉树的定义：
 *  平衡二叉树是任意结点的左右子树高度差绝对值不大于1的二叉搜索树。
 * 关键点：
 *  1、任意节点  （递归）
 *  2、左右子树的高度差绝对值不大于1 （递归式）
 *  3、二叉搜索树
 * *** 从下往上递归遍历树中的每一个结点，计算其左右子树的高度并且进行对比，只要有一个高度差的绝对值大于1，那么整棵树都会被判为不平衡。
*/

const isBalanced = function (root) {
  // 立一个flag，只要有一个高度差绝对值大于1，这个flag就会被置位false
  let flag = true
  // 定义递归逻辑
  function dfs (root) {
    // 如果是空树，高度记为 0；如果flag已经false了，那么就没有必要往下走了，直接return
    if (!root || !flag) return 0

    // 计算左子树的高度
    const left = dfs(root.left)
    // 计算右子树的高度
    const right = dfs(root.right)
    // 如果左右子树的高度差绝对值大于1，flag就破功了
    if (Math.abs(left - right) > 1) {
      flag = false
      // 后面再发生什么已经不重要了，返回一个不影响回溯计算的值
      return 0
    }
    // 返回当前子树的高度
    return Math.max(left, right) + 1
  }
  // 递归入库
  dfs(root)
  // 返回 flag 的值
  return flag
}

console.log('isBalanced', isBalanced({
  val: 3,
  left: {
    val: 9
  },
  right: {
    val: 20,
    left: {
      val: 15
    },
    right: {
      val: 7
    }
  }
}))



/**
 * *** 平衡二叉树的构造
 *
 * 题目2：
 * 给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与 原来的树有着相同的结点值。
 * 如果一棵二叉搜索树中，每个节点的两棵子树高度都不超过1，我们就称这棵二叉搜索树是平衡的。
 *
 *
 * 示例：
 *
 * 输入：root = [1,null,2,null,3,null,4,null,null]
 * 输出：[2,1,3,null,null,null,4]
 * 解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。
 *
 * 提示：
 * 树节点的数目在1 到 10^4之间。树节点的值互不相同，且在 1 到 10^5 之间。
 *
 * 解法（思路分析）：
 * 核心诉求：要求我们构造一棵二叉搜索树。
 *
 * 二叉搜索树的中序遍历序列是有序的！
 * 所谓有序数组，完全可以理解为二叉搜索树的中序遍历序列。
 *
 * 1、中序遍历求出有序数组
 * 2、逐个将二分出来的数字子序列“提”起来变成二叉搜索树。
*/
function TreeNode (val) {
  this.val = val
  this.left = this.right = null
}

const balaceBST = function (root) {
  // 初始化中序遍历序列数组
  const nums = []
  // 定义中序遍历二叉树，得到有序数组
  function inorder (root) {
    if (!root) return
    inorder(root.left)
    nums.push(root.val)
    inorder(root.right)
  }
  // 此方法和BST - 二叉搜索树中sortedArrayToBST方法一模一样
  // 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
  function buildAVL (low, high) {
    // 若low > high,则越界，说明当前索引范围对应的子树已经构建完毕
    if (low > high) return null
    // 取数组的中间值作为根结点值
    const mid = Math.floor(low + (high - low) / 2)
    // 创造当前树的根结点
    const cur = new TreeNode(num[mid])
    // 构建左子树
    cur.left = buildAVL(low, mid - 1)
    // 构建右子树
    cur.right = buildAVL(mid + 1, high)
    // 返回当前树的根结点
    return cur
  }
  // 调用中序遍历方法，求出nums
  inorder(root)
  // 基于nums 构造平衡二叉树
  return buildAVL(0, nums.length - 1)
}
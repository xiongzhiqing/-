/**
 * DFS（深度优先遍历） 核心思想 -- 试图穷举所有的完整路径。
 * BFS（广度优先遍历）
 * 这两种算法和栈、队列有着千丝万缕的关系。
 *
 *
 * DFS 深度优先搜索思想： 不撞南墙不回头的“迷宫游戏”
 * 原则：只要没有碰壁，就决不选择其它的道路，而是坚持向当前道路的深处挖掘——像这样将“深度”作为前进的第一要素的搜索方法，就是所谓的“深度优先搜索”。
 *
 *  DFS 算法其实就是回溯思想的体现。
 *
 * 有递归就回有回溯。
 *
 * 回溯算法的特别之处，在于其对应的题目往往要求你在递归过程中求出一个确切的解。
 *
 * 涉及剪枝操作的递归，我们一般称之为回溯。
*/

/**
 * 深度优先所有（DFS）
 * 本质：栈结构
 * 使用递归来模拟入栈、出栈的逻辑。
 *
 * 递归式就是我们选择道路的过程，而递归边界就是死胡同。
 * 二叉树的先序遍历正式深度优先搜索思想的递归实现。
 * 深度优先搜索过程就类似于树的先序遍历、是树的先序遍历的推广。
 *
 *
*/

/**
 * 首先，函数调用的底层，仍然是由栈来实现的。JS会维护一个叫“函数调用栈”的东西。preorder每调用一次自己，相关调用的上下文就回被push进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被pop出来，因此，即使二叉树的递归调用过程中，并没有出现栈這种数据结构，也依然改变不了递归的本职是栈的事实。
 * 其次，DFS作为一种思想，它和树的递归遍历一脉相承、却并不能完全地划伤等号 ---- DFS的解题场景其实有很多，其中有一类会要求我们记录每一层递归式里路径的状态，此时就会强依赖栈结构。
*/


// ***** 广度优先搜索思想——找到迷宫出口的另一种思路

/**
 * BFS 遍历规律：
 * 1、每访问王一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。
 * 2、站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。
 *
 * 丢弃已访问的坐标、记录新观察的坐标，这个顺序符合“先进先出”的原则。
 * BFS算法的实现过程， 和队列有着密不可分的关系。
 *
 * 依次访问队列里已经有的坐标，将其出队；记录从当前坐标触发可直接抵达的所有坐标，将其入队。
 *
*/

// function BFS (入口坐标) {
//   const queue = [] // 初始化队列queue
//   // 入口坐标首先入队
//   queue.push(入口坐标)
//   // 队列不为空，说明没有遍历完全
//   while (queue.length) {
//     const top = queue[0] // 取出队头元素

//     访问 top // 此处是一些和 top 相关的逻辑，比如记录它对应的信息、检查它的属性等等

//     // 注意这里也可以不用 for 循环，视题意而定
//     for (检查 top 元素出发能够遍历到的所有元素) {
//       queue.push(top能够直接抵达的元素)
//     }

//     queue.shift() // 访问完毕。将队头元素出队
//   }
// }

const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};

function BFS (root) {
  const queue = []

  queue.push(root)

  while (queue.length) {
    const top = queue[0]
    console.log(top.val)

    if (top.left) {
      queue.push(top.left)
    }

    if (top.right) {
      queue.push(top.right)
    }

    queue.shift()
  }
}

console.time('BFS')
console.log(BFS(root))
console.timeEnd('BFS')